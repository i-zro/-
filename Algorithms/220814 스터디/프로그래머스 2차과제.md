## 1번 문제 (100점)

<div class="challenge-markdown"><div class="markdown solarized-dark"><p>한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다. 예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 -2, 3, 0, 2, -5일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 0이므로 세 학생은 삼총사입니다. 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 0이므로 세 학생도 삼총사입니다. 따라서 이 경우 한국중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.</p>

<p>한국중학교 학생들의 번호를 나타내는 정수 배열 <code>number</code>가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를 return 하도록 solution 함수를 완성하세요.</p>

<hr>

<h5>제한사항</h5>

<ul>
<li>3 ≤ <code>number</code>의 길이 ≤ 13</li>
<li>-1,000 ≤ <code>number</code>의 각 원소 ≤ 1,000</li>
<li>서로 다른 학생의 정수 번호가 같을 수 있습니다.</li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>number</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>[-2, 3, 0, 2, -5]</td>
<td>2</td>
</tr>
<tr>
<td>[-3, -2, -1, 0, 1, 2, 3]</td>
<td>5</td>
</tr>
<tr>
<td>[-1, 1, -1, 1]</td>
<td>0</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong></p>

<ul>
<li>문제 예시와 같습니다.</li>
</ul>

<p><strong>입출력 예 #2</strong></p>

<ul>
<li>학생들의 정수 번호 쌍 (-3, 0, 3), (-2, 0, 2), (-1, 0, 1), (-2, -1, 3), (-3, 1, 2) 이 삼총사가 될 수 있으므로, 5를 return 합니다.</li>
</ul>

<p><strong>입출력 예 #3</strong></p>

<ul>
<li>삼총사가 될 수 있는 방법이 없습니다.</li>
</ul>
</div></div>

## 풀이
**1. 정렬 후 0부터 배열 길이 - 2 까지의 반복문을 통해 한 개의 원소 선택하기**

- 세 수의 합이 0이 되려면 나머지 두 수의 합이 선택한 원소(goal = number[i])의 음수값 이어야 한다.

**2. 투 포인터를 통해 두 원소의 합(goal)이 선택한 원소의 음수(goal) 인지 탐색하기**

1. tmp < goal 이면 tmp 를 증가하여야 하므로 left 1 증가

3. tmp > goal 이면 tmp 를 감소하여야 하므로 right 1 감소

2. tmp == goal 일 경우, number[left]와 number[right]가 같은지 아닌지 판단하기

2-1. 같을 경우, 가능한 경우의 수는 right - left ex ) [-5 5 5 5 5]

2-2. 다를 경우, 가능한 경우의 수는 number[right]와 동일한 수의 개수 ex) [-5, -2, 0, 2, 2, 3] => (-2,0,2) 케이스 2개인 거 찾기

- tmp == goal 일 경우에도, 정렬을 하였기 때문에 arr[left]와 같은 수가 존재할 수 있으므로 left를 1 증가

**3. 1, 2 과정을 반복한다.**


### 문제풀이
```python
def solution(number):
    answer = 0

    # 숫자 배열 정렬
    number.sort()

    # 한 개의 수를 우선 선택하고, 나머지 두 수를 선택해서 합한 후, 서로 빼줘서 0 되는 경우 찾기
    for i in range(len(number) - 2):
        left, right = i+1, len(number) - 1  # 극단의 수 2개 선택
        goal = -number[i]  # 한 개 수 선택하고, 그 수를 0으로 만들기 위한 goal 선택
        max_idx = len(number)

        while left < right:
            tmp = number[left] + number[right]
            # 1. 합한 수가 goal보다 작을 때
            if tmp < goal:
                left += 1

            # 2. 합한 수가 goal일 때 (target)
            elif tmp == goal :
                # 2-1.
                if number[left] == number[right]:
                    answer += right - left

                # 2-2.
                else:
                    if max_idx > right:
                        # 끝 값을 끝 right에 맞춰주기
                        max_idx = right

                        while number[right] == number[max_idx-1]:   # right에 있는 같은 수들 찾기
                            max_idx -= 1
                    answer += right - max_idx + 1

                # left 한 칸 밀어주기
                left += 1

            # 3. 합한 수가 goal보다 작을 때
            else:
                right -= 1                       
    return answer
```


## 2번 문제 (25점)
<div class="challenge-markdown"><div class="markdown solarized-dark"><p>철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다. 이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다. 철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데, 그들은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류에 더 관심이 많습니다. 그래서 잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다.</p>

<p>예를 들어, 롤케이크에 4가지 종류의 토핑이 올려져 있다고 합시다. 토핑들을 1, 2, 3, 4와 같이 번호로 표시했을 때, 케이크 위에 토핑들이 [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있습니다. 만약 세 번째 토핑(1)과 네 번째 토핑(3) 사이를 자르면 롤케이크의 토핑은 [1, 2, 1], [3, 1, 4, 1, 2]로 나뉘게 됩니다. 철수가 [1, 2, 1]이 놓인 조각을, 동생이 [3, 1, 4, 1, 2]가 놓인 조각을 먹게 되면 철수는 두 가지 토핑(1, 2)을 맛볼 수 있지만, 동생은 네 가지 토핑(1, 2, 3, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것이 아닙니다. 만약 롤케이크의 네 번째 토핑(3)과 다섯 번째 토핑(1) 사이를 자르면 [1, 2, 1, 3], [1, 4, 1, 2]로 나뉘게 됩니다. 이 경우 철수는 세 가지 토핑(1, 2, 3)을, 동생도 세 가지 토핑(1, 2, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것입니다. 공평하게 롤케이크를 자르는 방법은 여러가지 일 수 있습니다. 위의 롤케이크를 [1, 2, 1, 3, 1], [4, 1, 2]으로 잘라도 공평하게 나뉩니다. 어떤 경우에는 롤케이크를 공평하게 나누지 못할 수도 있습니다.</p>

<p>롤케이크에 올려진 토핑들의 번호를 저장한 정수 배열 <code>topping</code>이 매개변수로 주어질 때, 롤케이크를 공평하게 자르는 방법의 수를 return 하도록 solution 함수를 완성해주세요.</p>

<hr>

<h5>제한사항</h5>

<ul>
<li>1 ≤ <code>topping</code>의 길이 ≤ 1,000,000

<ul>
<li>1 ≤ <code>topping</code>의 원소 ≤ 10,000</li>
</ul></li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>topping</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>[1, 2, 1, 3, 1, 4, 1, 2]</td>
<td>2</td>
</tr>
<tr>
<td>[1, 2, 3, 1, 4]</td>
<td>0</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong></p>

<ul>
<li>롤케이크를 [1, 2, 1, 3], [1, 4, 1, 2] 또는 [1, 2, 1, 3, 1], [4, 1, 2]와 같이 자르면 철수와 동생은 각각 세 가지 토핑을 맛볼 수 있습니다. 이 경우 공평하게 롤케이크를 나누는 방법은 위의 두 가지만 존재합니다.</li>
</ul>

<p><strong>입출력 예 #2</strong></p>

<ul>
<li>롤케이크를 공평하게 나눌 수 없습니다.</li>
</ul>
</div></div>

### 1차 - 10점
```python
def solution(topping):
    answer = 0
    for i in range(1, len(topping)-1):
        left, right = len(set(topping[:i])), len(set(topping[i:]))
        if left == right:
            answer+=1

    return answer
```

### 2차 - 25점
```python
def find_left(mid, topping):
    ans = 0
    while True:
        mid -= 1
        if mid ==0:
            return ans
        left, right = len(set(topping[:mid])), len(set(topping[mid:]))
        if left == right:
            ans+=1
        else:
            return ans

def find_right(mid, topping):
    ans = 0
    while True:
        mid += 1
        if mid == len(topping):
            return ans
        left, right = len(set(topping[:mid])), len(set(topping[mid:]))
        if left == right:
            ans+=1
        else:
            return ans


def solution(topping):
    answer = 0
    max_idx = len(topping)
    mid = max_idx // 2 
    
    while True:
        left, right = len(set(topping[:mid])), len(set(topping[mid:]))
        tmp = 1
        
        if left == right:
            answer += 1
            if len(set(topping[:mid-1])) == len(set(topping[mid-1:])):
                answer += find_left(mid, topping)
            if len(set(topping[:mid+1])) == len(set(topping[mid+1:])):
                answer += find_right(mid, topping)
            return answer
        elif left > right:
            answer += find_right(mid, topping)
            return answer
        else:
            answer += find_left(mid, topping)
            return answer
```

## 3번 문제
<div class="challenge-markdown"><div class="markdown solarized-dark"><p>강철부대의 각 부대원이 여러 지역에 뿔뿔이 흩어져 특수 임무를 수행 중입니다. 지도에서 강철부대가 위치한 지역을 포함한 각 지역은 유일한 번호로 구분되며, 두 지역 간의 길을 통과하는 데 걸리는 시간은 모두 1로 동일합니다. 임무를 수행한 각 부대원은 지도 정보를 이용하여 최단시간에 부대로 복귀하고자 합니다. 다만 적군의 방해로 인해, 임무의 시작 때와 다르게 되돌아오는 경로가 없어져 복귀가 불가능한 부대원도 있을 수 있습니다.</p>

<p>강철부대가 위치한 지역을 포함한 총지역의 수 <code>n</code>, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 <code>roads</code>, 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 <code>sources</code>, 강철부대의 지역 <code>destination</code>이 주어졌을 때, 주어진 <code>sources</code>의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 solution 함수를 완성해주세요. 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1입니다.</p>

<h5>제한사항</h5>

<ul>
<li>3 ≤ <code>n</code> ≤ 100,000

<ul>
<li>각 지역은 정수 1부터 <code>n</code>까지의 번호로 구분됩니다.</li>
</ul></li>
<li>2 ≤ <code>roads</code>의 길이 ≤ 500,000

<ul>
<li><code>roads</code>의 원소의 길이 = 2</li>
<li><code>roads</code>의 원소는 [a, b] 형태로 두 지역 a, b가 서로 왕복할 수 있음을 의미합니다.(1 ≤ a, b ≤ n, a ≠ b)</li>
<li>동일한 정보가 중복해서 주어지지 않습니다.

<ul>
<li>동일한 [a, b]가 중복해서 주어지지 않습니다.</li>
<li>[a, b]가 있다면 [b, a]는 주어지지 않습니다.</li>
</ul></li>
</ul></li>
<li>1 ≤ <code>sources</code>의 길이 ≤ 500

<ul>
<li>1 ≤&nbsp;<code>sources[i]</code>&nbsp;≤ n</li>
</ul></li>
<li>1 ≤ <code>destination</code> ≤ n</li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>n</th>
<th>roads</th>
<th>sources</th>
<th>destination</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>3</td>
<td>[[1, 2], [2, 3]]</td>
<td>[2, 3]</td>
<td>1</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>5</td>
<td>[[1, 2], [1, 4], [2, 4], [2, 5], [4, 5]]</td>
<td>[1, 3, 5]</td>
<td>5</td>
<td>[2, -1, 0]</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong></p>

<ul>
<li>지역 2는 지역 1과 길로 연결되어 있기 때문에, 지역 2에서 지역 1의 최단거리는 1입니다.</li>
<li>지역 3에서 지역 1로 이동할 수 있는 최단경로는 지역 3 → 지역 2 → 지역 1 순으로 이동하는 것이기 때문에, 지역 3에서 지역 1의 최단거리는 2입니다. </li>
<li>따라서 [1, 2]를 return합니다.</li>
</ul>

<p><strong>입출력 예 #2</strong></p>

<ul>
<li>지역 1에서 지역 5의 최단경로는 지역 1 → 지역 2 → 지역 5 또는 지역 1 → 지역 4 → 지역 5 순으로 이동하는 것이기 때문에, 최단거리는 2입니다.</li>
<li>지역 3에서 지역 5로 가는 경로가 없기 때문에, 지역 3에서 지역 5로 가는 최단거리는 -1입니다.</li>
<li>지역 5에서 지역 5는 이동할 필요가 없기 때문에, 최단거리는 0입니다.</li>
<li>따라서 [2, -1, 0]을 return합니다.</li>
</ul>
</div></div>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg3NjQ0NjY4MiwtODY5MjQ5NjA0LC0xNz
I3MjY1MjU1LC00NDkxMzM0OTYsLTUxMzk2OTAzNiwxNzY1MzI5
NDU2XX0=
-->