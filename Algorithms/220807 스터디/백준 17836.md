# [BFS / 중급] 17836 공주님을 구해라! (백준, Python, 실버1)

## 문제

용사는 마왕이 숨겨놓은 공주님을 구하기 위해 (_N_,  _M_) 크기의 성 입구 (1,1)으로 들어왔다. 마왕은 용사가 공주를 찾지 못하도록 성의 여러 군데 마법 벽을 세워놓았다. 용사는 현재의 가지고 있는 무기로는 마법 벽을 통과할 수 없으며, 마법 벽을 피해 (_N_,  _M_) 위치에 있는 공주님을 구출해야만 한다.

마왕은 용사를 괴롭히기 위해 공주에게 저주를 걸었다. 저주에 걸린 공주는 _T_시간 이내로 용사를 만나지 못한다면 영원히 돌로 변하게 된다. 공주님을 구출하고 프러포즈 하고 싶은 용사는 반드시  _T_시간 내에 공주님이 있는 곳에 도달해야 한다. 용사는 한 칸을 이동하는 데 한 시간이 걸린다. 공주님이 있는 곳에 정확히  _T_시간만에 도달한 경우에도 구출할 수 있다. 용사는 상하좌우로 이동할 수 있다.

![](https://upload.acmicpc.net/62b6063d-4d01-4836-9793-94ab99f032f2/)

성에는 이전 용사가 사용하던 전설의 명검 "그람"이 숨겨져 있다. 용사가 그람을 구하면 마법의 벽이 있는 칸일지라도, 단숨에 벽을 부수고 그 공간으로 갈 수 있다. "그람"은 성의 어딘가에 반드시 한 개 존재하고, 용사는 그람이 있는 곳에 도착하면 바로 사용할 수 있다. 그람이 부술 수 있는 벽의 개수는 제한이 없다.

우리 모두 용사가 공주님을 안전하게 구출 할 수 있는지, 있다면 얼마나 빨리 구할 수 있는지 알아보자.

## 입력

첫 번째 줄에는 성의 크기인  _N_,  _M_  그리고 공주에게 걸린 저주의 제한 시간인 정수  _T_가 주어진다. 첫 줄의 세 개의 수는 띄어쓰기로 구분된다. (3 ≤  _N_,  _M_ ≤ 100, 1 ≤  _T_  ≤ 10000)

두 번째 줄부터  _N_+1번째 줄까지 성의 구조를 나타내는 _M_개의 수가 띄어쓰기로 구분되어 주어진다. 0은 빈 공간, 1은 마법의 벽, 2는 그람이 놓여있는 공간을 의미한다. (1,1)과 (_N_,_M_)은 0이다.

## 출력

용사가 제한 시간  _T_시간 이내에 공주에게 도달할 수 있다면, 공주에게 도달할 수 있는 최단 시간을 출력한다.

만약 용사가 공주를  _T_시간 이내에 구출할 수 없다면, "`Fail`"을 출력한다.

## 예제 입력 1  복사

6 6 16
0 0 0 0 1 1
0 0 0 0 0 2
1 1 1 0 1 0
0 0 0 0 0 0
0 1 1 1 1 1
0 0 0 0 0 0

## 예제 출력 1  복사

10

![](https://upload.acmicpc.net/6a09042e-acea-410c-8776-bc3498c44cc5/)

주황색 선을 따라 검을 구하지 않고, 벽을 돌아가면 16시간만에 공주님에게 도착할 수 있다.

반면, 녹색선을 따라 "그람"을 구해, 벽을 부수고 공주님께 가면 10시간만에 도달할 수 있다.

## 예제 입력 2  복사

3 4 100
0 0 0 0
1 1 1 1
0 0 2 0

## 예제 출력 2  복사

Fail

## 풀이
풀이과정 자체는 간단했지만 잔 실수로 인해 계속 풀이 에러가 났던 문제이다.

풀이 과정 아이디어는 다음과 같다.

1. q에 갈 x, y 및 depth 까지 저장
2. 만약 그람의 위치 찾으면 (2) 지금까지의 depth+1 + 남은거리 더하기
3. 최종 N,M 도달 시에 현재 depth와 2를 통해 간 거리 중 최솟값을 결과로 반환

#### 실수 모음
1. visited = [[False for f in range(M)] for ff in range(N)] 여기서 첨에 둘다 M으로 줌.
2. 그람으로 찾은 거리 temp는 temp <= T 이어야 하지만 계속 temp < T로 구함. 문제를 잘읽어야하는게 딱 T에 도착해도 도달 가능한 거기 때문에 잘 따져줘야 함.


### 문제 풀이
```python
import sys
from collections import deque

input = sys.stdin.readline

N, M, T = map(int, input().split())

maps = [list(map(int, input().split())) for _ in range(N)]
visited = [[False for f in range(M)] for ff in range(N)]

movin = [[1,0], [0,1], [-1,0], [0,-1]]
q = deque()
q.append((0,0,0))
visited[0][0] = True
result = float('inf')

while q:
  x, y, d = q.popleft()

  if x == N-1 and y == M-1:
    result = min(result, d)
    break

  if d+1 > T:
    break
    
  for mov in movin:
    nx, ny = x+mov[0], y+mov[1]
    if (-1<nx<N and -1<ny<M) and not visited[nx][ny]:  # 경계점 아니고 미 방문시
      if not maps[nx][ny]:
        visited[nx][ny] = True
        q.append((nx, ny, d+1))
      elif maps[nx][ny] == 1:  # 벽이면
        continue
      elif maps[nx][ny] == 2:  # 그람 찾음
        temp = d + 1  # 그람까지 온 거리
        temp += abs(N-1 -nx) + abs(M-1 - ny)
        visited[nx][ny] = True
        if temp <= T:
          result = temp

if result > T:
  print("Fail")
else:
  print(result)
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMxNjQ2MjczLC0yNTA0MjI4NTZdfQ==
-->