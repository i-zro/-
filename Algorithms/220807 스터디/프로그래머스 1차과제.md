## 1번 문제 : 두 수의 짝꿍 (73.7점)

<div class="challenge-markdown"><div class="markdown solarized-dark"><p>두 정수 <code>X</code>, <code>Y</code>의 임의의 자리에서 공통으로 나타나는 정수 k(0 ≤ k ≤ 9)들을 이용하여 만들 수 있는 가장 큰 정수를 두 수의 짝꿍이라 합니다(단, 공통으로 나타나는 정수 중 서로 짝지을 수 있는 숫자만 사용합니다). <code>X</code>, <code>Y</code>의 짝꿍이 존재하지 않으면, 짝꿍은 -1입니다. <code>X</code>, <code>Y</code>의 짝꿍이 0으로만 구성되어 있다면, 짝꿍은 0입니다.</p>

<p>예를 들어, <code>X</code> = 3403이고 <code>Y</code> = 13203이라면, <code>X</code>와 <code>Y</code>의 짝꿍은 <code>X</code>와 <code>Y</code>에서 공통으로 나타나는 3, 0, 3으로 만들 수 있는 가장 큰 정수인 330입니다. 다른 예시로 <code>X</code> = 5525이고 <code>Y</code> = 1255이면 <code>X</code>와 <code>Y</code>의 짝꿍은 <code>X</code>와 <code>Y</code>에서 공통으로 나타나는 2, 5, 5로 만들 수 있는 가장 큰 정수인 552입니다(<code>X</code>에는 5가 3개, <code>Y</code>에는 5가 2개 나타나므로 남는 5 한 개는 짝 지을 수 없습니다.)<br>
두 정수 <code>X</code>, <code>Y</code>가 주어졌을 때, <code>X</code>, <code>Y</code>의 짝꿍을 return하는 solution 함수를 완성해주세요.</p>

<h5>제한사항</h5>

<ul>
<li>3 ≤ <code>X</code>, <code>Y</code>의 길이(자릿수) ≤ 3,000,000입니다.</li>
<li><code>X</code>, <code>Y</code>는 0으로 시작하지 않습니다.</li>
<li><code>X</code>, <code>Y</code>의 짝꿍은 상당히 큰 정수일 수 있으므로, 문자열로 반환합니다.</li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>X</th>
<th>Y</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>"100"</td>
<td>"2345"</td>
<td>"-1"</td>
</tr>
<tr>
<td>"100"</td>
<td>"203045"</td>
<td>"0"</td>
</tr>
<tr>
<td>"100"</td>
<td>"123450"</td>
<td>"10"</td>
</tr>
<tr>
<td>"12321"</td>
<td>"42531"</td>
<td>"321"</td>
</tr>
<tr>
<td>"5525"</td>
<td>"1255"</td>
<td>"552"</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong></p>

<ul>
<li><code>X</code>, <code>Y</code>의 짝꿍은 존재하지 않습니다. 따라서 "-1"을 return합니다.</li>
</ul>

<p><strong>입출력 예 #2</strong></p>

<ul>
<li><code>X</code>, <code>Y</code>의 공통된 숫자는 0으로만 구성되어 있기 때문에, 두 수의 짝꿍은 정수 0입니다. 따라서 "0"을 return합니다.</li>
</ul>

<p><strong>입출력 예 #3</strong></p>

<ul>
<li><code>X</code>, <code>Y</code>의 짝꿍은 10이므로, "10"을 return합니다.</li>
</ul>

<p><strong>입출력 예 #4</strong></p>

<ul>
<li><code>X</code>, <code>Y</code>의 짝꿍은 321입니다. 따라서 "321"을 return합니다.</li>
</ul>

<p><strong>입출력 예 #5</strong></p>

<ul>
<li>지문에 설명된 예시와 같습니다.</li>
</ul>
</div></div>

## 풀이
### 문제풀이
```python
def solution(X, Y):
    from collections import deque
    answer = ""
    combi = list()  # 짝꿍가능 수
    x = deque(list(X))
    y = list(Y)
    while x:
        xx = x.popleft()
        if xx in y:
            y_idx = y.index(xx)
            y.pop(y_idx)
            combi.append(int(xx))
            
    if not combi:
        return "-1"
    if not sum(combi):
        return "0"

    answer = "".join(map(str, sorted(combi, reverse=True)))
    return answer
```

## 2번 문제 : xyz 마트, 구현 (통과 완료)

<div class="challenge-markdown"><div class="markdown solarized-dark"><p>XYZ 마트는 일정한 금액을 지불하면 10일 동안 회원 자격을 부여합니다. XYZ 마트에서는 회원을 대상으로 매일 한 가지 제품을 할인하는 행사를 합니다. 할인하는 제품은 하루에 하나씩만 구매할 수 있습니다. 알뜰한 정현이는 자신이 원하는 제품과 수량이 할인하는 날짜와 10일 연속으로 일치할 경우에 맞춰서 회원가입을 하려 합니다.</p>

<p>예를 들어, 정현이가 원하는 제품이 바나나 3개, 사과 2개, 쌀 2개, 돼지고기 2개, 냄비 1개이며, XYZ 마트에서 15일간 회원을 대상으로 할인하는 제품이 날짜 순서대로 치킨, 사과, 사과, 바나나, 쌀, 사과, 돼지고기, 바나나, 돼지고기, 쌀, 냄비, 바나나, 사과, 바나나인 경우에 대해 알아봅시다. 첫째 날부터 열흘 간에는 냄비가 할인하지 않기 때문에 첫째 날에는 회원가입을 하지 않습니다. 둘째 날부터 열흘 간에는 바나나를 원하는 만큼 할인구매할 수 없기 때문에 둘째 날에도 회원가입을 하지 않습니다. 셋째 날, 넷째 날, 다섯째 날부터 각각 열흘은 원하는 제품과 수량이 일치하기 때문에 셋 중 하루에 회원가입을 하려 합니다.</p>

<p>정현이가 원하는 제품을 나타내는 문자열 배열 <code>want</code>와 정현이가 원하는 제품의 수량을 나타내는 정수 배열 <code>number</code>, XYZ 마트에서 할인하는 제품을 나타내는 문자열 배열 <code>discount</code>가 주어졌을 때, 회원등록시 정현이가 원하는 제품을 모두 할인 받을 수 있는 회원등록 날짜의 총 일수를 return 하는 solution 함수를 완성하시오. 가능한 날이 없으면 0을 return 합니다.</p>

<hr>

<h5>제한사항</h5>

<ul>
<li>1 ≤ <code>want</code>의 길이 = <code>number</code>의 길이 ≤ 10

<ul>
<li>1 ≤ <code>number</code>의 원소 ≤ 10</li>
<li><code>number[i]</code>는 <code>want[i]</code>의 수량을 의미하며, <code>number</code>의 원소의 합은 10입니다.</li>
</ul></li>
<li>10 ≤ <code>discount</code>의 길이 ≤ 100,000</li>
<li><code>want</code>와 <code>discount</code>의 원소들은 알파벳 소문자로 이루어진 문자열입니다.

<ul>
<li>1 ≤ <code>want</code>의 원소의 길이, <code>discount</code>의 원소의 길이 ≤ 12</li>
</ul></li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>want</th>
<th>number</th>
<th>discount</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>["banana", "apple", "rice", "pork", "pot"]</td>
<td>[3, 2, 2, 2, 1]</td>
<td>["chicken", "apple", "apple", "banana", "rice", "apple", "pork", "banana", "pork", "rice", "pot", "banana", "apple", "banana"]</td>
<td>3</td>
</tr>
<tr>
<td>["apple"]</td>
<td>[10]</td>
<td>["banana", "banana", "banana", "banana", "banana", "banana", "banana", "banana", "banana", "banana"]</td>
<td>0</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong></p>

<ul>
<li>문제 예시와 같습니다.</li>
</ul>

<p><strong>입출력 예 #2</strong></p>

<ul>
<li>사과가 할인하는 날이 없으므로 0을 return 합니다.</li>
</ul>
</div></div>


## 풀이

1. 10일간 마트 할인 품목을 자르고, 
2. 해당 리스트에 원하는 항목의 품목이 더 많을 때만 세어준 후,
3. 해당 개수가 want 길이보다 길면 ( = 원하는 품목 모두 할인 되면) 결과 + 1

### 문제풀이
```python
from collections import defaultdict
def solution(want, number, discount):
    answer = 0
    mart = defaultdict(int)

    # want와 number 딕셔너리로 만들기
    for w in range(len(want)):
        mart[want[w]] = number[w]

    # print(mart)

    for d in range(len(discount) - 9):
        dc = discount[d:d+10]   # 10일 간 세일품목
        cnt = 0
        for w in want:
            if mart[w] <= dc.count(w):  # 원하는 품목 할인받는 날이 더 많으면
                cnt+=1
        if cnt >= len(want):    # 원하는 품목 모두 할인되면
            answer += 1
    return answer
```

## 3번 문제 : 영재 택배상자
<div class="challenge-markdown"><div class="markdown solarized-dark"><p>영재는 택배상자를 트럭에 싣는 일을 합니다. 영재가 실어야 하는 택배상자는 크기가 모두 같으며 1번 상자부터 n번 상자까지 번호가 증가하는 순서대로 컨테이너 벨트에 일렬로 놓여 영재에게 전달됩니다. 컨테이너 벨트는 한 방향으로만 진행이 가능해서 벨트에 놓인 순서대로(1번 상자부터) 상자를 내릴 수 있습니다. 하지만 컨테이너 벨트에 놓인 순서대로 택배상자를 내려 바로 트럭에 싣게 되면 택배 기사님이 배달하는 순서와 택배상자가 실려 있는 순서가 맞지 않아 배달에 차질이 생깁니다. 따라서 택배 기사님이 미리 알려준 순서에 맞게 영재가 택배상자를 실어야 합니다.</p>

<p>만약 컨테이너 벨트의 맨 앞에 놓인 상자가 현재 트럭에 실어야 하는 순서가 아니라면 그 상자를 트럭에 실을 순서가 될 때까지 잠시 다른 곳에 보관해야 합니다. 하지만 고객의 물건을 함부로 땅에 둘 수 없어 보조 컨테이너 벨트를 추가로 설치하였습니다. 보조 컨테이너 벨트는 앞 뒤로 이동이 가능하지만 입구 외에 다른 면이 막혀 있어서 맨 앞의 상자만 뺄 수 있습니다(즉, 가장 마지막에 보조 컨테이너 벨트에 보관한 상자부터 꺼내게 됩니다). 보조 컨테이너 벨트를 이용해도 기사님이 원하는 순서대로 상자를 싣지 못 한다면, 더 이상 상자를 싣지 않습니다.</p>

<p>예를 들어, 영재가 5개의 상자를 실어야 하며, 택배 기사님이 알려준 순서가 기존의 컨테이너 벨트에 네 번째, 세 번째, 첫 번째, 두 번째, 다섯 번째 놓인 택배상자 순서인 경우, 영재는 우선 첫 번째, 두 번째, 세 번째 상자를 보조 컨테이너 벨트에 보관합니다. 그 후 네 번째 상자를 트럭에 싣고 보조 컨테이너 벨트에서 세 번째 상자 빼서 트럭에싣습니다. 다음으로 첫 번째 상자를 실어야 하지만 보조 컨테이너 벨트에서는 두 번째 상자를, 기존의 컨테이너 벨트에는 다섯 번째 상자를 꺼낼 수 있기 때문에 더이상의 상자는 실을 수 없습니다. 따라서 트럭에는 2개의 상자만 실리게 됩니다.</p>

<p>택배 기사님이 원하는 상자 순서를 나타내는 정수 배열 <code>order</code>가 주어졌을 때, 영재가 몇 개의 상자를 실을 수 있는지 return 하는 solution 함수를 완성하세요.</p>

<hr>

<h5>제한사항</h5>

<ul>
<li>1 ≤ <code>order</code>의 길이 ≤ 1,000,000</li>
<li><code>order</code>는 1이상 <code>order</code>의 길이 이하의 모든 정수가 한번씩 등장합니다.</li>
<li><code>order[i]</code>는 기존의 컨테이너 벨트에 <code>order[i]</code>번째 상자를 i+1번째로 트럭에 실어야 함을 의미합니다.</li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>order</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>[4, 3, 1, 2, 5]</td>
<td>2</td>
</tr>
<tr>
<td>[5, 4, 3, 2, 1]</td>
<td>5</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong></p>

<ul>
<li>문제 예시와 같습니다.</li>
</ul>

<p><strong>입출력 예 #2</strong></p>

<ul>
<li>모든 상자를 보조 컨테이너 벨트에 모두 넣고, 역순으로 하나씩 빼서 트럭에 싣습니다.</li>
</ul>
</div></div>

## 문제
1. 

### 문제 풀이
```python
def solution(order):
    from collections import deque

    #   컨베이어 벨트 순서
    q = deque([i for i in range(1, len(order)+1)])
    #   보조 컨베이어 벨트
    helper = deque()

    answer = 0
    while q:
        if q[0] == order[answer]:
            q.popleft()
            answer += 1
        else:
            if helper and helper[-1] == order[answer]: # 보조 컨베이어벨트 끝과 현재 들어가야하는 애 같을 때
                helper.pop()
                answer += 1
            else:
                helper.append(q.popleft())

    while helper:
        if order[answer] == helper[-1]:
            answer+=1
            helper.pop()
        else:
            break
            
    return answer
```


## 4번 문제
<div class="challenge-markdown"><div class="markdown solarized-dark"><p>한수는 직사각형 모양의 공간에 놓인 동전들을 뒤집는 놀이를 하고 있습니다. 모든 동전들은 앞과 뒤가 구분되어 있으며, 동전을 뒤집기 위해서는 같은 줄에 있는 모든 동전을 뒤집어야 합니다. 동전들의 초기 상태와 목표 상태가 주어졌을 때, 초기 상태에서 최소 몇 번의 동전을 뒤집어야 목표 상태가 되는지 알아봅시다.</p>

<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/7efaaecf-e627-40a8-ab90-60550523ccb0/2%EC%B0%A8%EC%9B%90%201.png" title="" alt="2차원 1.png"></p>

<p>예를 들어, 위 그림에서 맨 왼쪽이 초기 상태, 맨 오른쪽이 목표 상태인 경우에 대해 알아봅시다. 그림에서 검은색 원은 앞면인 동전, 흰색 원은 뒷면인 동전을 의미합니다. 초기 상태에서 2행과 4행의 돌들을 뒤집으면, 두 번째 그림이 됩니다. 그 후, 2열, 4열, 5열의 돌들을 순서대로 뒤집는 다면, 총 5번의 동전 뒤집기를 통해 목표 상태가 되며, 이 경우가 최소인 경우입니다.</p>

<p>직사각형 모양의 공간에 놓인 동전들의 초기 상태를 나타내는 2차원 정수 배열 <code>beginning</code>, 목표 상태를 나타내는 <code>target</code>이 주어졌을 때, 초기 상태에서 목표 상태로 만들기 위해 필요한 동전 뒤집기 횟수의 최솟값을 return 하는 solution 함수를 완성하세요. 단, 목표 상태를 만들지 못하는 경우에는 -1을 return 합니다.</p>

<hr>

<h5>제한사항</h5>

<ul>
<li>1 ≤ <code>beginning</code>의 길이 = <code>target</code>의 길이 ≤ 10</li>
<li>1 ≤ <code>beginning[i]</code>의 길이 = <code>target[i]</code>의 길이 ≤ 10

<ul>
<li><code>beginning[i][j]</code>와 <code>target[i][j]</code>는 i + 1행 j + 1열의 동전의 상태를 나타내며, 0 또는 1의 값으로 주어집니다.</li>
<li>0은 동전의 앞면을, 1은 동전의 뒷면을 의미합니다.</li>
</ul></li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>beginning</th>
<th>target</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>[[0, 1, 0, 0, 0], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0], [1, 0, 1, 1, 0], [0, 1, 0, 1, 0]]</td>
<td>[[0, 0, 0, 1, 1], [0, 0, 0, 0, 1], [0, 0, 1, 0, 1], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]]</td>
<td>5</td>
</tr>
<tr>
<td>[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</td>
<td>[[1, 0, 1], [0, 0, 0], [0, 0, 0]]</td>
<td>-1</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong></p>

<ul>
<li>문제 예시와 같습니다.</li>
</ul>

<p><strong>입출력 예 #2</strong></p>

<ul>
<li>목표 상태를 만들지 못합니다. 따라서 -1을 return 합니다.</li>
</ul>
</div></div>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTUyNTkxODM2MSwtMTM3MDE4NDc0MCwtMT
A3MjQ4MzQ4MywtMTA0NTcyODA4OSwtMTUxNTY3NTMxMSw0NzQw
MjkwMjgsMTIyMDYwNjk0Nl19
-->