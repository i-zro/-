# 배운 내용
## 첫 번째 도전 - 기본적인 CI/CD 구축 및 1개의 EC2

## 웹 서버
- HTTP 요청을 읽어서 응답을 해주는 프로그램
- 상용으로 많이 쓰이는 웹 서버 프로그램은 크게 apache와 nginx 있음.

### Apache vs nginx

#### 1. Apache
- 기본적으로 2가지 방식이 있음.
    - Prefork MPM(Multi Processing Module)
        - HTTP 요청이 올 때마다 프로세스 복제해서 각각 별도 프로세스에서 해당 HTTP 요청 처리
    - Worker MPM
        - 하나의 HTTP 연결 후, 여러 요청을 처리하기 위해 복제된 프로세스 내에서 여러 쓰레드를 생성해서 여러 HTTP 요청


- 아무래도 이런 방식은 프로세스를 생성하든 쓰레드를 생성하든 요청에 따라 뭔가를 생성해야한다. 더 좋은 방법이 없을까?


#### 2. Nginx
- Event Driven 방식으로 구동
    - 하나의 프로세스로 동작하며, HTTP 요청을 event로 비동기식으로 처리함.
        - 대부분의 HTTP 응답은 결국 html 파일을 제공하는 것이므로, IO 작업. IO 작업으로 event를 포워딩하고, 요청 순이 아닌, 요청이 끝난 순으로 처리함.
    - HTTP 요청마다 프로세스든 쓰레드등 생성이 필요없으므로, 시스템 자원 관리에 장점이 있음.

#### 결론
Apache와 nginx 중 HTML 파일 사이즈, 어떤 추가 기능을 쓰느냐 등 다양한 조건 때문에 무엇이 더 무조건 성능이 좋다고는 이야기 할 수 없음. 하지만 많은 접속자가 있을 경우, 시스템 자원 관리 효율성 때문에 Nginx가 일반적으로는 성능이 더 좋을 수 있으므로 해당 프로젝트에서는 Nginx를 사용함.

## 배포 전략

## 두 번째 도전 - ECS 구축
### 순서
- [x] (front) 도커파일 만들기
- [x] (front) ECR에 푸시
- [x] (front) ECR 이미지 풀 받아서 잘 동작하는 지 확인
- [x] 작업 정의 생성
- [x] ALB 생성
- [x] Fargate 클러스터 생성
- [x] Fargate 서비스 생성 및 작업정의 연결
- [ ] (back) 도커파일 만들기
- [x] 

## 도커
### 도커란?
다양한 운영체제와 시스템 환경에서 서버 셋업을 위한 작업이 모두 다르고 복잡.

도커는 컨테이너 기반의 가상화 플랫폼이라서, 컨테이너 상에 서버를 셋업 해놓을 수 있음. 

그래서 컨테이너를 실행만 하면, 서버 이전이나 서버 패키지 버전 등등으로 일일이 서버 설정할 필요없이, 동일한 서버 셋업 가능.

### 마이크로 서비스와 DevOps, 도커
- 각 마이크로 서비스를 `도커`로 개발
- 초대용량 서비스 유지보수를 위한 서버 핸들링 (ex. 네트워크 트래픽 관리) => 쿠버네티스

### docker image
- docker 컨테이너를 생성하기 위한 명령들을 가진 템플릿

### docker container
- docker 컨테이너가 리눅스 컨테이너 형태로 실행한 상태 (instance)

### EC2 도커 실행 환경 구축

```
sudo yum update -y

sudo yum install docker -y

sudo service docker start

sudo usermod -aG docker ec2-user
```


## Dockerize
### [Front] React Dockerize

#### [오류] npm Err
##### [원인]
지속적으로 yarn install/build 과정에서 여러 모듈에서 npm Err가 났다.
이유는 node alpine 이미지를 사용해서 였는데, alpine은 경량화 된 이미지라서 python 등이 설치되어 있지 않고, 이를 사용하는 모듈의 설치가 실패되었다.

##### [해결]
우선 `FROM node:16` 이미지를 사용하는 방식으로 해결했다. 하지만 이미지가 거대해져서 좋은 해결방식은 아닌 것 같다. 추후에 더 좋은 방법을 찾아 볼 예정이다.






---
참고
[# [CICD / ECS] CodePipeline으로 ECS Fargate 배포 자동화 #1 - 개요, 아키텍처](https://nyyang.tistory.com/97?category=994566)

[# 「초심자」무작정 해보는 ECS 컨테이너 서비스 구축 – 1 (ECR에 이미지 푸시)](https://dev.classmethod.jp/articles/ecs-container-service-establishment/)

	p.s 추후에 이 블로그 그림처럼 vpc/subnet 내용 정리하기
	
![](https://i.imgur.com/dUskNmS.png)

https://www.44bits.io/ko/post/getting-started-with-ecs-fargate

[AWS ECS fargate를 사용한 Appilication 배포 - 1](https://neo-blog.tistory.com/42)

---


### ECR
---
참고

[AWS-ECR 사용하기](http://ryeon9445.com/develop/1-AWS-ECR-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/)

---

- ECR 레포지토리 생성
ECR 리포지토리를 private하게 만들어주었다.
![](https://i.imgur.com/ZlmiP5j.png)

---
#### [오류] github actions -> push -> EOF 에러
##### [원인]
github actions를 통해 ECR에 로그인하여 ECR로 푸시하는 yaml 파일을 작성하였는데, 계속 원인모를 EOF 에러가 났다.
원인은 permissions를 설정해주지 않아서 였다.


##### [해결]
![](https://i.imgur.com/LgbPmqW.png)

레포지토리의 permissions에 들어가서 정책을 편집하여, deploy해야하는 IAM 계정에 push 권한을 부여했다.

###### 정책
```
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowPushAndPull",
      "Effect": "Allow",
      "Principal": {
        "AWS": [
          "arn:aws:iam::[숫자]:user/[IAM User명]"
        ]
      },
      "Action": [
        "ecr:BatchCheckLayerAvailability",
        "ecr:BatchGetImage",
        "ecr:CompleteLayerUpload",
        "ecr:GetDownloadUrlForLayer",
        "ecr:InitiateLayerUpload",
        "ecr:PutImage",
        "ecr:UploadLayerPart"
      ]
    }
  ]
}
```
---

- 이미지를 pull 받기 위해 AmazonEC2ContainerRegistryFullAccess 권한 가지는 IAM 사용자 생성
![](https://i.imgur.com/z5db0ud.png)

- aws configure 해서 해당 액세스키, 비밀번호, 리전 입력

- aws ecr get-login --no-include-email --region ap-northeast-2
하면 로그인 할 수 있는 명령어들 출력
이걸 복사해서 로그인 하면 된다.

### Fargate vs EC2
#### 개요
    - ECS with EC2
    AWS 자체 개발하여 제공하는 컨테이너 서비스
        - 장점
        EC2 인스턴스에 대한 full 컨트롤, GPU 인스턴스 활용 용이
        spot 인스턴스 활용 가능하여 최대 90% 비용 절감
        - 단점
        EC2 인스턴스를 직접 관리해야함, 예: 인스턴스에 대한 보안 패치 등을 직접 처리해야함

    - ECS with Fargate
    AWS 람다와 EC2 기반의 ECS 컨테이너의 중간 쯤에 위치한 서비스, EC2 인스턴스 관리에 대해 걱정 안해도 됨
        - 장점
        관리할 서버가 없음
        CPU/Memory 선택이 상대적으로 좀 더 용이함
        Fargate Spot을 사용하여 70% 절감된 금액으로 이용할 가능성 있음
        - 단점
        awsvpc로 네트워크 옵션이 제한됨
    
    
- 비용 측면
 
	ec2는 t3.micro 시간당 0.013 USD 2vcpu 1GiBt2.micro 시간당 0.0144 USD 1vcpu 1GiB
	 
	fargate는
	vcpu당 0.04656 USDGB당 0.00511 USD
	 
	fargate를 1vcpu 1GB 사용한다면 그 합이 0.05167 USD 정도가 되는데
	 
	동급의 ec2에 비해서 많게는 3배까지 비용이 비싸다.

#### 결론
비록 비용적 측면에서 큰 단점이 있지만, 이전에 EC2를 통해서만 구축해봤기에 직접 관리할 부분이 적다는 장점을 가진 fargate를 경험 및 학습적 측면에서 선택해 봤다.

### 배포 전략 선택
ECS에서 자체적으로 2가지의 배포전략을 선택할 수 있었다.

![](https://i.imgur.com/Ui2yaQS.png)

#### 1. 롤링 ( Rolling )

- 인스턴스를 정해놓은 단위로 교체하는 방식이다.  서비스를 구성하는 총 서버의 댓수가 10대라면 2대씩 롤링 업데이트를 진행하겠다고 한다면, 새로운 버전 2대가 생성되고, 정상적으로 서비스가 가능한 상태일때 트래픽이 2대로 전환되고, 구버전 2대는 서비스에서 제외한다. ( draining ) 이 방식으로 2대씩 순차적으로 새로운 버전으로 교체되는 방식이다. 이 방식은 가용 리소스가 적은 상태에서도 배포가 가능하다. 업데이트 프로세스 동안 두 가지 버전의 컨테이너가 동시에 실행되기 때문에 버전 호환성의 문제가 발생할 수 있다.

#### 2. 블루 그린 ( Blue/Green )

  - 구 버전을 블루 신 버전을 그린이라고 해서 붙여진 이름으로, 동일한 서버를 미리 구축한뒤에 라우팅을 순간적으로 전환하여 새로운 버전을 배포하는 방식이다. 빠른 롤백이 가능한 장점이 있고, 운영 환경을 유지한채로 새롭게 배포될 버전의 테스트도 가능한 구성이 되나, 자원이 두배로 필요하게 되어 비용이 많이 방생하는 단점 도 존재한다. 

### Fargate SSH 접속

---

참고

[# 9 steps to SSH into an AWS Fargate managed container](https://medium.com/ci-t/9-steps-to-ssh-into-an-aws-fargate-managed-container-46c1d5f834e2)

---

### ALB 생성 및 Fargate로 로드밸런서 프론트엔드 확인해보기
---
참고

https://dev.classmethod.jp/articles/lets-make-aws-fargate-first/

---

### Private RDS 터널링 방법
---

참고

https://velog.io/@ynsoo1225/AWS-Bastion-Host%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-IntelliJ%EC%97%90%EC%84%9C-Private-Subnet-RDS-%EC%97%B0%EA%B2%B0

---

### 유용한 명령어
##### 리눅스
- 전체 폴더에서 폴더 찾기
find / -name 폴더명 -type d

# 결과

### 계정 기초보안
루트계정의 Access Key를 탈취하여 고비용의 리소스를 생성하거나 고비용의 서비스를 신청하여 단기간에 수만 달러에 달하는 비용을 발생시키는 피해가 발생하므로, 꼭 추가 보안 설정이 필요함.

1. 루트 사용자 MFA 설정

AWS 콘솔에 로그인할 때 아이디/패스워드 외 추가 인증을 더하는 것

2. 루트 사용자 Access Key 삭제

액세스 키는 아이디/패스워드 인증과 동일한 권한을 갖지만 AWS CLI, PowerShell용 도구, AWS SDK 또는 직접 AWS API 호출을 통해 AWS를 프로그래밍 방식으로 호출할 수 있도록 해주는 반드시 필요한 존재이지만 액세스 키가 루트 사용자 권한으로 사용될 때는 그 용도 만큼이나 매우 강력해서 탈취되어 악용하면 광범위한 영역에서 피해를 줄 수 있음. 따라서, 특별한 이유가 없다면 루트 사용자 계정에는 반드시 액세스 키를 삭제하거나 비활성화되어 있어야 함.

3. IAM 사용자 설정

`admin` 사용자를 따로 만들어 AdministratorAccess 권한만 부여. 이렇게 빌링 권한을 가지지 않은 사용자를 이용하여, AWS 리소스에 대한 액세스를 안전하게 제어.

### 웹 서버 - Nginx
Apache와 nginx 중 HTML 파일 사이즈, 어떤 추가 기능을 쓰느냐 등 다양한 조건 때문에 무엇이 더 무조건 성능이 좋다고는 이야기 할 수 없음. 하지만 많은 접속자가 있을 경우, 시스템 자원 관리 효율성 때문에 Nginx가 일반적으로는 성능이 더 좋을 수 있으므로 해당 프로젝트에서는 Nginx를 사용함.

### 배포 전략

### 도커 
추후 서버의 확장성을 고려하여 도커라이징 하기로 결정함.


<!--stackedit_data:
eyJoaXN0b3J5IjpbNTgyMjc2MDgwLC0xODU1ODQ2Nzg5LDE1OD
c2NjMzMzAsLTE4MzExNjAxODQsLTY2MzQ0NDQxLDExMTY3NjY1
LC0xNjY5NzI3MDE4LDcxMjYyMjkwMCwxODI4MDU2MjkxLDEyOT
c4NjE5MzAsMTkyMzE5Mzk1Miw0NDY3NjM2NTIsMTU4NjU5NDUy
LDE3NjIxNjI4OTUsMTc5MzI2MzI3MCwxODkwMzI1NjYzLDEwOD
k2NTE2MzIsMTQ4NzkwNjM0LC0xMjM1MzM1MDIwLC0xNTc3NTY5
MDI2XX0=
-->