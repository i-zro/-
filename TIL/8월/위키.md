# 배운 내용
## 웹 서버
- HTTP 요청을 읽어서 응답을 해주는 프로그램
- 상용으로 많이 쓰이는 웹 서버 프로그램은 크게 apache와 nginx 있음.

### Apache vs nginx

#### 1. Apache
- 기본적으로 2가지 방식이 있음.
    - Prefork MPM(Multi Processing Module)
        - HTTP 요청이 올 때마다 프로세스 복제해서 각각 별도 프로세스에서 해당 HTTP 요청 처리
    - Worker MPM
        - 하나의 HTTP 연결 후, 여러 요청을 처리하기 위해 복제된 프로세스 내에서 여러 쓰레드를 생성해서 여러 HTTP 요청


- 아무래도 이런 방식은 프로세스를 생성하든 쓰레드를 생성하든 요청에 따라 뭔가를 생성해야한다. 더 좋은 방법이 없을까?


#### 2. Nginx
- Event Driven 방식으로 구동
    - 하나의 프로세스로 동작하며, HTTP 요청을 event로 비동기식으로 처리함.
        - 대부분의 HTTP 응답은 결국 html 파일을 제공하는 것이므로, IO 작업. IO 작업으로 event를 포워딩하고, 요청 순이 아닌, 요청이 끝난 순으로 처리함.
    - HTTP 요청마다 프로세스든 쓰레드등 생성이 필요없으므로, 시스템 자원 관리에 장점이 있음.

#### 결론
Apache와 nginx 중 HTML 파일 사이즈, 어떤 추가 기능을 쓰느냐 등 다양한 조건 때문에 무엇이 더 무조건 성능이 좋다고는 이야기 할 수 없음. 하지만 많은 접속자가 있을 경우, 시스템 자원 관리 효율성 때문에 Nginx가 일반적으로는 성능이 더 좋을 수 있으므로 해당 프로젝트에서는 Nginx를 사용함.

## 배포 전략

## 도커
### 도커란?
다양한 운영체제와 시스템 환경에서 서버 셋업을 위한 작업이 모두 다르고 복잡.

도커는 컨테이너 기반의 가상화 플랫폼이라서, 컨테이너 상에 서버를 셋업 해놓을 수 있음. 

그래서 컨테이너를 실행만 하면, 서버 이전이나 서버 패키지 버전 등등으로 일일이 서버 설정할 필요없이, 동일한 서버 셋업 가능.

### 마이크로 서비스와 DevOps, 도커
- 각 마이크로 서비스를 `도커`로 개발
- 초대용량 서비스 유지보수를 위한 서버 핸들링 (ex. 네트워크 트래픽 관리) => 쿠버네티스

### docker image
- docker 컨테이너를 생성하기 위한 명령들을 가진 템플릿

### docker container
- docker 컨테이너가 리눅스 컨테이너 형태로 실행한 상태 (instance)

### nginx 도커라이즈
```
$ amazon-linux-extras install docker
```
```
service docker start
```
```
$ docker pull nginx
```
```
$ sudo amazon-linux-extras install epel
```

### Public Subnet에 EC2 생성 이후 Private Subnet으로 옮기기
1. 기존 Public Subnet EC2 이미지 새엇ㅇ
https://developerbee.tistory.com/m/216

## Dockerize
### [Front] React Dockerize

#### [오류] npm Err
##### [원인]
지속적으로 yarn install/build 과정에서 여러 모듈에서 npm Err가 났다.
이유는 node alpine 이미지를 사용해서 였는데, alpine은 경량화 된 이미지라서 python 등이 설치되어 있지 않고, 이를 사용하는 모듈의 설치가 실패되었다.

##### [해결]
우선 `FROM node:16` 이미지를 사용하는 방식으로 해결했다. 하지만 이미지가 거대해져서 좋은 해결방식은 아닌 것 같다. 추후에 더 좋은 방법을 찾아 볼 예정이다.

## 두 번째 도전 - ECS 구축

### 순서
- [x] (front) 도커파일 만들기
- [x] (front) ECR에 푸시
- [x] 

---
참고
https://dev.classmethod.jp/articles/ecs-container-service-establishment/

p.s 추후에 이 블로그 그림처럼 vpc/subnet 내용 정리하기
![](https://i.imgur.com/dUskNmS.png)


---


### ECR
---
참고

http://ryeon9445.com/develop/1-AWS-ECR-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/

---

- ECR 레포지토리 생성
ECR 리포지토리를 private하게 만들어주었다.
![](https://i.imgur.com/ZlmiP5j.png)

#### [오류] github actions -> push -> EOF 에러
##### [원인]
github actions를 통해 ECR에 로그인하여 ECR로 푸시하는 yaml 파일을 작성하였는데, 계속 원인모를 EOF 에러가 났다.
원인은 permissions를 설정해주지 않아서 였다.


##### [해결]
![](https://i.imgur.com/LgbPmqW.png)

레포지토리의 permissions에 들어가서 정책을 편집하여, deploy해야하는 IAM 계정에 push 권한을 부여했다.

###### 정책
```
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowPushAndPull",
      "Effect": "Allow",
      "Principal": {
        "AWS": [
          "arn:aws:iam::[숫자]:user/[IAM User명]"
        ]
      },
      "Action": [
        "ecr:BatchCheckLayerAvailability",
        "ecr:BatchGetImage",
        "ecr:CompleteLayerUpload",
        "ecr:GetDownloadUrlForLayer",
        "ecr:InitiateLayerUpload",
        "ecr:PutImage",
        "ecr:UploadLayerPart"
      ]
    }
  ]
}
```

- 이미지를 pull 받기 위해 AmazonEC2ContainerRegistryFullAccess 권한 가지는 IAM 사용자 생성
![](https://i.imgur.com/z5db0ud.png)

- aws configure 해서 해당 액세스키, 비밀번호, 리전 입력

- aws ecr get-login --no-include-email --region ap-northeast-2
하면 로그인 할 수 있는 명령어들 출력
이걸 복사해서 로그인 하면 됨.




# 결과

### 계정 기초보안
루트계정의 Access Key를 탈취하여 고비용의 리소스를 생성하거나 고비용의 서비스를 신청하여 단기간에 수만 달러에 달하는 비용을 발생시키는 피해가 발생하므로, 꼭 추가 보안 설정이 필요함.

1. 루트 사용자 MFA 설정

AWS 콘솔에 로그인할 때 아이디/패스워드 외 추가 인증을 더하는 것

2. 루트 사용자 Access Key 삭제

액세스 키는 아이디/패스워드 인증과 동일한 권한을 갖지만 AWS CLI, PowerShell용 도구, AWS SDK 또는 직접 AWS API 호출을 통해 AWS를 프로그래밍 방식으로 호출할 수 있도록 해주는 반드시 필요한 존재이지만 액세스 키가 루트 사용자 권한으로 사용될 때는 그 용도 만큼이나 매우 강력해서 탈취되어 악용하면 광범위한 영역에서 피해를 줄 수 있음. 따라서, 특별한 이유가 없다면 루트 사용자 계정에는 반드시 액세스 키를 삭제하거나 비활성화되어 있어야 함.

3. IAM 사용자 설정

`admin` 사용자를 따로 만들어 AdministratorAccess 권한만 부여. 이렇게 빌링 권한을 가지지 않은 사용자를 이용하여, AWS 리소스에 대한 액세스를 안전하게 제어.

### 웹 서버 - Nginx
Apache와 nginx 중 HTML 파일 사이즈, 어떤 추가 기능을 쓰느냐 등 다양한 조건 때문에 무엇이 더 무조건 성능이 좋다고는 이야기 할 수 없음. 하지만 많은 접속자가 있을 경우, 시스템 자원 관리 효율성 때문에 Nginx가 일반적으로는 성능이 더 좋을 수 있으므로 해당 프로젝트에서는 Nginx를 사용함.

### 배포 전략

### 도커 
추후 서버의 확장성을 고려하여 도커라이징 하기로 결정함.


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTUxMzQ4MjM5NywxNzkzMjYzMjcwLDE4OT
AzMjU2NjMsMTA4OTY1MTYzMiwxNDg3OTA2MzQsLTEyMzUzMzUw
MjAsLTE1Nzc1NjkwMjYsMjg3NTM5MzQwLC0xOTc4NTQzODE0LD
UwNzkyNDgwMywyNjIyODgzNDcsLTE2MDk3NDc1NDcsOTYyMDUx
ODQsLTM4OTU4MjU2OV19
-->